
[toc]


* * *
## **项目总览**

这是一个基于MATLAB的雷达信号处理项目。其核心目标是处理雷达采集的原始二进制(`.bin`)数据，通过一系列信号处理步骤，最终实现动目标检测和参数测量。

整个处理流程可以概括为三个主要阶段，形成一条清晰的数据处理链：

1.  **数据读取与格式转换**：将物理上分散的 `.bin` 二进制文件作为连续的数据流读取，解析出每一帧的I/Q回波数据，并将其转换为MATLAB的 `.mat` 格式，方便后续处理。
2.  **动目标检测 (MTD)**：加载 `.mat` 格式的帧数据，通过脉冲压缩和多普勒处理（FFT）生成距离-速度二维谱，以检测移动目标。
3.  **恒虚警率 (CFAR) 检测**：在MTD处理结果的基础上，应用CFAR算法来抑制噪声和杂波的干扰，提取真实的目标点，并进行可视化。

* * *

## **信号处理算法**
### 脉冲压缩

#### 1\. 功能与目的

脉冲压缩技术旨在解决雷达探测中 **“作用距离”** 与 **“距离分辨率”** 之间的矛盾。

-   **作用距离**：为了探测到更远的目标，雷达需要发射具有更大能量的信号，这通常意味着使用更宽的脉冲。
-   **距离分辨率**：为了能区分两个距离很近的目标，雷达需要发射脉宽很窄的信号。

脉冲压缩技术通过发射一个经过编码的宽脉冲信号（最常见的是线性调频信号，LFM或Chirp信号），并在接收端进行特殊处理，可以将回波信号在**时间**上 **“压缩”** 成一个非常窄的脉冲。这样，雷达就能同时获得**宽脉冲的远探测距离**和**窄脉冲的高距离分辨率**，并且处理过程还能显著**提高信号的信噪比（SNR）**。

#### 2\. 实现方法

该函数采用的是最经典的脉冲压缩方法——**匹配滤波（Matched Filtering）**。

-   **匹配滤波器**：理论证明，在白噪声背景下，能使输出信噪比达到最大的滤波器就是匹配滤波器。其冲激响应是输入信号（即雷达发射的参考信号）的时间反转再取复共轭。
    
-   **快速卷积**：直接在时域计算回波信号与滤波器冲激响应的卷积，计算量非常大。该函数利用了**傅里叶变换的卷积定理**来实现“快速卷积”



### MTD算法原理及步骤

#### 第1步：数据准备（相参脉冲串）

MTD处理的前提是获得一串**相参**的雷达脉冲回波。相参意味着每个脉冲的发射相位都是已知的、稳定的，这样我们才能通过比较连续回波之间的相位变化来提取多普勒信息。

-  **在代码中**，送入 `fun_MTD_produce` 的 `echo` 或 `echo_segment` 就是这样的数据。它通常是一个二维矩阵，维度为 **(脉冲数, 距离点数)**，也称为“快时间-慢时间”数据。

#### 第2步：脉冲压缩（可选但常用）

在进行多普勒处理之前，通常会先对信号进行脉冲压缩。这不是MTD的必需步骤，但绝大多数现代脉冲多普勒雷达都会执行此操作。

-   **目的**：提高信号的距离分辨率和信噪比。
-   **在代码中**：`fun_MTD_produce.m` 函数首先调用 `fun_lss_pulse_compression`，这表明您的处理流程包含了脉冲压缩这一预处理环节。



#### 第3步：多普勒处理（MTD的核心）

这是将目标从背景杂波中分离出来的核心步骤。它通过对每个距离单元的脉冲串进行**傅里叶变换（FFT）** 来实现。

整个过程在 `fun_Process_MTD.m` 文件中有清晰的体现：

1.  **选取距离单元**：处理流程会遍历所有距离单元（矩阵的每一列）。对于固定的一个距离单元，所有脉冲（所有行）在该点的回波值构成了一个时间序列。
    
    ```Matlab
    for Index=1:Len_PRT
        % ... 处理 ProSignal(:,Index) ...
    end
    ```
2.  **加窗（Windowing）**：在进行FFT之前，通常会对这个时间序列乘以一个窗函数（如 Kaiser, Hamming, Hanning等），目的是**减少FFT的频谱泄漏**，防止强目标的能量泄漏到旁边的频率单元，影响对弱目标的检测。
    - **在代码中**：使用了Kaiser窗。`Signal_Win = ProSignal(:,Index) .* WindowData;`。
3.  **快速傅里叶变换（FFT）**：对加窗后的脉冲串数据进行FFT。这个操作将信号从 **(脉冲)时间域** 转换到了 **(多普勒)频域**。
    
    - 静止目标（如地面）的多普勒频移为零。
    - 运动目标会根据其朝向雷达的速度产生一个非零的多普勒频移。
    - **在代码中**：`FFT_Signal = fftshift(fft(Signal_Win, Num_PRTperFrame));`。`fftshift` 的作用是将零频分量移动到频谱的中心，便于观察。

##### **慢时间FFT：原始数据（距离-脉冲矩阵）-> 距离-多普勒（速度）图**

这是我们处理前的样子。矩阵中的每个点都是一个复数，代表了在该脉冲、该距离上的回波信号幅度和相位。
-   **行**：代表**快时间**，也就是**距离单元**。快时间（快时间维就是沿着数据矩阵的行方向，行方向是指行数加1的方向）
    
-   **列**：代表**慢时间**，也就是**脉冲序列**。慢时间（慢时间维就是沿着数据矩阵的列方向，列方向是指列数加1的方向）
    
假设我们有8个脉冲，探测了1024个距离单元，那么我们得到一个 `1024 x 8` 的矩阵。
假设在我们的探测范围内有两个目标：
 **静止目标 (地杂波)**：位于第200个距离单元，速度为0。
 **运动目标 (汽车)**：位于第600个距离单元，正在以20 m/s的速度朝我们飞来。

              <-------------------- 慢时间 (8个脉冲) ------------------->
              脉冲1      脉冲2      脉冲3      脉冲4      脉冲5      ...
      ^   行1
      |   行2
      |   ...
      快  行200 [静止目标的回波, 幅度强, 相位不变]
      时  ...
      间  行600 [运动目标的回波, 幅度中, 相位线性变化]
      |   ...
      |   行1024
      v

然后，沿慢时间方向做慢时间FFT提取目标的速度信息：
1. 选择一个距离单元 (比如第600行)：一个行向量, 包含8个脉冲在该距离上的回波
2. 对这个行向量进行FFT：得到一个8点的多普勒频谱
3. 对所有1024行重复此操作：最终的距离-多普勒图 (RDM) (1024 x 8)

在这个新的矩阵中，**列的物理意义从“脉冲”变成了“速度”**。

              <-------------------- 速度 (8个速度单元) ------------------->
              -40m/s    -20m/s      0m/s     +20m/s    +40m/s      ...
      ^   行1
      |   行2
      |   ...
      距  行200 .....................★ (强峰值)......................  (静止目标)
      离  ...
      |   行600 .....................................★ (中等峰值).....  (运动目标)
      |   ...
      |   行1024
      v
    

**结论：慢时间FFT将“距离-脉冲”图转换为了“距离-速度”图，从而检测出运动目标。**



##### **快时间FFT：一般用于提取距离信息，FMCW体制雷达常用**
这里，我们用脉冲压缩已经距离信息了






![1750061079647](image/README/1750061079647.png)




1.  **生成距离-多普勒图（Range-Doppler Map, RDM）**：对所有距离单元都执行完上述操作后，得到的新矩阵 `MTD_Signal` 就是RDM。它的维度变为 **(速度单元, 距离单元)**。在这个图上，一个运动目标会表现为一个明亮的像素点，其位置对应了目标的距离和速度。




    




#### 第4步：杂波抑制与处理

即使经过了多普勒处理，来自地面的杂波（速度为零）能量通常还是最强的。为了更好地“看到”运动目标，需要进行杂波抑制。

-   **在代码中**：`fun_MTD_produce.m` 调用了 `fun_0v_pressing(MTD_Signal)`。这个函数的作用是**压制零速通道**，即将RDM中代表零速度及其附近区域的数值强制置零或设为平均值，有效去除地杂波的干扰。

#### 第5步：目标检测

在干净的距离-多普勒图上，最后一步就是确定哪些点是真实目标。

-   **简单方法**：`fun_Process_MTD.m` 文件中通过 `[MTD_Signal_R(Index),~] = max(Abs_Signal);` 这样的操作，在每个距离单元上选取了速度维的最大值，这是一种最简单的检测方式。
-   **常用方法**：在工程应用中，通常使用**恒虚警率（Constant False Alarm Rate, CFAR）** 检测器。CFAR会根据目标点周围的杂波/噪声水平自动计算一个检测门限，只有超过该门限的点才被判断为目标。这可以使雷达在不同杂波环境下都能保持稳定的检测性能。

综上所述，MTD是一个将原始回波数据逐步提炼，最终在速度-距离平面上凸显运动目标的过程，而本 代码完整地实现了**脉冲压缩 → 加窗 → FFT多普勒处理 → 杂波抑制**这一经典流程。










## **文件间依赖关系分析**

项目的执行流程由几个核心的"主脚本"驱动，这些主脚本调用一系列功能函数来完成特定任务。以下是主要的处理流程和文件依赖关系：


**主处理流程：`bin` -> `.mat` (I/Q) -> `.mat` (MTD) -> `.mat` (CFAR)**


-   **阶段1**: `bin_to_mat_xzr.m` (及其V1, V2版本) 是入口，它调用 `frameDataRead_CrossFile_xzr.m` 来读取数据帧。而 `frameDataRead_CrossFile_xzr.m` 内部则依赖 `dataFullPathGen.m` 来定位正确的 `.bin` 文件，并实现了核心的跨文件数据读取和拼接逻辑。
-   **阶段2**: `main_produce_dataset_win_xzr.m` 负责加载上一阶段生成的 `.mat` 文件，并调用 `fun_MTD_produce.m` 来执行MTD处理。`fun_MTD_produce` 是一个协调者，它依次调用 `fun_lss_pulse_compression` (进行脉冲压缩)、`fun_Process_MTD` (进行FFT)和 `fun_0v_pressing` (零速抑制)。
-   **阶段3**: `main_cfar.m` 负责加载MTD结果，并调用其内部定义的本地函数 `fun_CFARflag` 来执行CFAR检测。`fun_CFARflag` 进一步调用 `executeCFAR.m`，后者是CFAR算法的核心实现，它通过调用 `Function_CFAR1D_sub.m` 和 `Function_CFAR1D_sub_fixCells.m` 分别在速度维和距离维上执行一维CFAR。

## **各文件作用功能解释**

根据功能，所有文件可分为以下几类：

#### 1\. 主流程与控制脚本

-   `bin_to_mat_xzr.m` (及 `_V1`, `_V2`, `Copy_of_...` 版本): **数据转换入口**。负责将原始的 `.bin` 文件转换为 `.mat` 文件。不同版本反映了功能的演进，特别是 `V1` 和 `V2` 版本引入了更健壮的跨文件读取功能以处理被分割的数据帧。
-   `main_produce_dataset_win_xzr.m`: **MTD数据集生成脚本**。通过滑动窗口的方式加载原始I/Q数据，调用MTD处理函数，并保存结果。
-   `main_cfar.m`: **CFAR检测与可视化脚本**。加载MTD数据，执行CFAR检测，保存检测结果，并能选择性地绘制距离-速度谱和检测结果图。
-   `main.m` & `main_DMX_SignalProcessing.m`: **独立的仿真与处理流程**。`main.m` 主要用于仿真目标、添加杂波并对仿真数据进行完整的处理链验证和绘图。`main_DMX_SignalProcessing.m` 则是针对另一种雷达模式（"6km模式"）的完整信号处理、参数测量和可视化的脚本。

#### 2\. 数据读取与解析函数

-   `frameDataRead_CrossFile_xzr.m`: **核心跨文件数据读取函数**。负责从一系列 `.bin` 文件中读取一个完整的逻辑数据帧，能够处理PRT（脉冲重复时间）包在文件边界被截断的情况，将下一文件的数据拼接起来形成完整的PRT包。
-   `frameDataRead_A_xzr_V2.m`: **核心数据帧解析器**。负责解析一个PRT包的帧头、信号数据和帧尾，根据数据类型（ADC, DDC, DBF）对原始字节进行解析和数学运算，最终形成可用的信号矩阵。
-   `dataFullPathGen.m` (及 `Copy_of_...`): **文件名生成器**。一个辅助函数，根据文件索引号生成符合特定命名规则的完整文件路径。
-   `CrossFileDataReader.m`: **早期的跨文件读取器**。这是一个结构化的函数，旨在创建一个可以跨文件读取数据的"读取器对象"，但似乎在当前主流程中未被直接使用，可能是早期的实现版本。
-   `angle_read.m`: **角度数据提取脚本**。用于批量读取 `BasebandRawData_mat` 文件夹下的 `.mat` 文件，提取其中的角度信息 (`angleCodeSeries`)，并将其汇总保存到一个单独的 `angles.mat` 文件中。
-   `Show_Read.m`: **带显示功能的数据读取函数**。一个旧版的 `frameDataRead` 函数，除了读取数据外，还包含了实时绘制I/Q信号波形的功能，主要用于调试和可视化。

#### 3\. 信号处理核心函数

-   **MTD 相关:**
    -   `fun_MTD_produce.m`: **MTD处理协调函数**。调用脉冲压缩、MTD核心处理和零速抑制等功能，完成从时域回波到距离-速度谱的转换。
    -   `fun_lss_pulse_compression.m`: **多脉冲压缩函数**。针对包含多种脉冲类型（如短、中、长脉冲）的回波，分段进行脉冲压缩。
    -   `fun_pulse_compression.m`: **单脉冲压缩函数**。通过FFT实现的快速卷积，完成匹配滤波。
    -   `fun_Process_MTD.m`: **核心MTD处理函数**。对脉冲压缩后的数据，在每个距离单元上进行加窗和FFT，以获得多普勒信息。
    -   `fun_0v_pressing.m`: **零速抑制函数**。将MTD结果中零速或近零速的多普勒单元置零，以抑制地物等静止杂波。
-   **CFAR 相关:**
    -   `executeCFAR.m`: **二维CFAR执行函数**。实现"先速度维，后距离维"的二维CFAR检测策略。
    -   `Function_CFAR1D_sub.m`: **标准一维CFAR函数**。实现基于单元平均的CFAR算法，用于估计噪声门限。
    -   `Function_CFAR1D_sub_fixCells.m`: **指定单元的一维CFAR函数**。`Function_CFAR1D_sub`的变体，仅对输入参数指定的单元格进行CFAR检测。

#### 4\. 辅助与工具函数

-   `clip.m`: **数据剪切脚本**。一个独立脚本，用于加载MTD处理后的数据，并对其进行距离维和速度维的剪切，以提取感兴趣的区域。
-   `fun_add_clutter.m`: **杂波添加函数**。用于在仿真的目标回波上叠加真实的背景杂波数据。
-   `fun_SCR.m`: **信杂比(SCR)控制函数**。调整仿真目标回波的功率，以达到设定的信杂比。
-   `fun_iSTC.m`: **STC补偿函数**。读取STC（灵敏度时间控制）曲线，对回波信号进行补偿。
-   `fun_lss_range_concate.m`: **距离拼接函数**。用于在多脉冲压缩后，删除重叠或无效的距离区间，将有效的距离段拼接起来。
-   `freValueGen.m`: **频率值生成函数**。根据输入的频点索引号，返回对应的雷达工作频率值。
-   `angle_KvalueGen.m`: **测角K值生成函数**。提供一个硬编码的矩阵，其中包含了用于俯仰角测量的比例系数（K值），这些值可能随设备和频率变化。
-   `motionParaMeasure.m`: **运动参数测量函数**。在CFAR检测出的目标点附近进行插值，以更精确地估计目标的距离、速度和俯仰角。
-   `ampConstrWidthEst.m`: **幅度谱宽度估计函数**。用于估计频谱峰值在特定分贝下的宽度。
-   `temp.m`, `ywoD_sinc.m`: **临时测试与绘图脚本**。`temp.m` 用于测试和比较脉冲波形，`ywoD_sinc.m` 用于绘制二维sinc函数图像。

#### 5\. 文档

-   `README.md`: **项目说明文档**。提供了项目的总体流程、文件功能、依赖关系、运行说明和未来的改进方向，是理解整个项目的关键。


### `bin_to_mat_xzr.m`的依赖关系
#### 整体功能与架构

这套脚本的核心目标是将雷达采集的原始二进制数据转换为更易于分析的 `.mat` 文件。其最关键的特性是能够将存储在多个按顺序编号的 `.bin` 文件中的数据视为一个无缝的、连续的数据流。当数据读取操作需要跨越文件边界时（例如，一个数据帧的末尾在文件A，开头在文件B），系统能够自动处理这一转换，对上层调用函数保持透明。

该系统采用分层架构设计，各司其职：

-   **顶层控制层**: `bin_to_mat_xzr.m` 是总控制器，负责整个流程的调度、参数配置和最终文件的保存。
-   **帧级处理层**: `FrameDataRead_xzr.m` 负责读取并解析一个完整“帧”（Frame）的数据，每帧由多个“脉冲重复时间”（PRT）构成。
-   **底层读取层**: `read_continuous_file_stream.m` 是执行实际文件I/O操作的底层函数，也是实现跨文件连续读取功能的核心。
-   **辅助工具**: `DataFullPathGen.m` 和 `manage_retry_count.m` 提供文件名生成和错误重试计数等支持功能。

#### 各脚本功能详解

##### 1\. `bin_to_mat_xzr.m` (主控制脚本)

这是用户需要运行的主文件，它驱动整个数据转换过程。

-   **初始化**: 脚本开始时会清除所有辅助函数的持久化状态（persistent variables），确保每次运行都是一个全新的开始。它还负责设置雷达系统的基础参数，如采样率、通道数等。
-   **加载配置**: 从外部文本文件（`DBFcoef.txt`）中读取数字波束形成（DBF）所需的加权系数。
-   **主循环**: 通过一个 `while` 循环，按顺序处理指定数量的数据帧。
-   **调用处理函数**: 在循环内部，它调用 `FrameDataRead_xzr` 函数来读取和处理单个逻辑帧的数据。
-   **错误处理与重试**: 如果 `FrameDataRead_xzr` 未能成功读取一个完整的帧，脚本会利用 `manage_retry_count` 函数进行有限次数的重试，以避免因数据损坏而陷入死循环。
-   **保存结果**: 每当一个数据帧被成功处理后，脚本会将其保存为一个独立的 `.mat` 文件，文件名与帧的编号对应。

###### 1.1\. `FrameDataRead_xzr.m` (帧级数据处理函数)

此函数是数据解析和处理的核心，负责从数据流中提取并构建一个完整的逻辑帧。

-   **状态管理**: 利用持久化变量 `current_prt` 和 `last_frameRInd` 来记录当前帧内PRT的处理进度。
-   **PRT循环**: 函数内部包含一个 `while` 循环，该循环会持续读取和处理PRT，直到构成一帧所需的PRT数量 (`prtNum`) 被满足。
-   **调用底层读取**: 在每次PRT循环中，它会多次调用 `read_continuous_file_stream` 函数，以获取PRT的帧头、实时参数、信号数据和帧尾的原始字节流。
-   **数据解析**: 它会详细解析帧头数据，提取出脉冲采样点数、数据类型（ADC、DDC或DBF）、伺服方位角等关键元数据。
-   **信号处理**: 根据从帧头解析出的数据类型，脚本会对信号数据进行相应的处理。
    -   对于DDC（数字下变频）数据，它会将复数信号与预先加载的DBF系数矩阵相乘，以完成数字波束形成。
    -   对于其他类型的数据，则进行相应的格式重整。
-   **返回输出**: 当一帧的所有PRT都处理完毕后，函数会返回处理好的多波束信号数据矩阵 `sig_data_DBF_allprts`、伺服角度序列 `servo_angle`，以及两个状态标志：`frameCompleted`（表示该帧是否完整）和 `is_global_stream_end`（表示是否已到达所有数据文件的末尾）。

###### 1.2\. `read_continuous_file_stream.m` (跨文件连续流读取器)

这是整个系统的技术基石，它使得上层函数无需关心数据具体存储在哪个物理文件中。

-   **持久化状态**: 该函数通过一系列持久化变量（如 `file_id_m` 文件句柄, `current_file_index_m` 文件索引, `current_file_pos_m` 文件内指针位置）来“记忆”当前文件的读取状态。
-   **跨文件逻辑**: 当被要求读取指定长度的数据时，它会判断请求是否会超出当前文件的末尾。
    -   如果数据请求跨越了文件边界，它会先读取当前文件中剩余的所有数据，关闭该文件，然后利用 `DataFullPathGen` 生成下一个文件的路径并打开它，接着从新文件的开头读取剩余所需的数据，最后将两部分数据拼接起来返回。
    -   如果读取操作正好在文件末尾结束，它会关闭当前文件并准备在下次调用时打开新文件。
-   **输出**: 函数返回原始的字节数据 (`uint8` 格式)，具体的类型转换由上层函数 `FrameDataRead_xzr` 负责。

###### 1.3\. `DataFullPathGen.m` (文件路径生成器)

这是一个小而重要的辅助函数，用于根据文件索引号生成标准格式的文件名。

-   **格式化命名**: 它能够根据文件索引号的大小，自动在数字前补零，生成如 `1.000001.bin` 或 `1.000010.bin` 这样的文件名。
-   **路径处理**: 它能检查并使用名为“雷达原始数据”的子目录（如果存在）。

###### 1.4\. `manage_retry_count.m` (重试计数器)

一个简单的状态管理工具，用于在主脚本中实现读取重试逻辑。

-   它使用一个持久化变量来充当计数器，可以通过不同的输入参数（`'increment'`, `'reset'`）来增加或重置计数值。这可以防止在数据流中遇到永久性错误时程序卡死。

###### 1.5\. `Copy_of_frameDataRead_A_xzr_V2.m` (未使用/备份文件)

从文件名和代码内容来看，这似乎是 `FrameDataRead_xzr.m` 的一个早期版本或备份副本。主脚本 `bin_to_mat_xzr.m` 并没有调用它。通过比较可以发现，`FrameDataRead_xzr.m` 中对帧头的解析更为详尽，表明它是当前正在使用的、功能更完善的版本。

##### 执行流程总结

1.  **启动**: 用户运行 `bin_to_mat_xzr.m`。
2.  **帧处理循环**: 脚本进入主循环，尝试处理第 `N` 帧。
3.  **调用帧处理器**: 它调用 `FrameDataRead_xzr` 来获取第 `N` 帧的完整数据。
4.  **PRT处理循环**: `FrameDataRead_xzr` 进入其内部循环，开始处理该帧的第一个PRT。
5.  **调用底层读取器**: 为了获取PRT的头部、数据和尾部，`FrameDataRead_xzr` 多次调用 `read_continuous_file_stream`。
6.  **文件I/O**: `read_continuous_file_stream` 负责从磁盘读取字节。如果遇到文件末尾，它会自动关闭当前文件，打开下一个文件，并无缝地继续读取。
7.  **解析与计算**: `FrameDataRead_xzr` 接收到底层返回的原始字节后，进行解析、数据类型转换和DBF计算。
8.  **完成一帧**: 当一帧的所有PRT都处理完毕后，`FrameDataRead_xzr` 将整合好的数据返回给主脚本。
9.  **保存与迭代**: `bin_to_mat_xzr.m` 接收到数据后，将其保存为 `frame_N.mat`，然后开始处理第 `N+1` 帧。这个过程会一直持续到处理完所有指定的帧或到达数据流的尽头。



### `main_produce_dataset_win_xzr.m` 的依赖关系

此脚本的功能是加载由 `bin_to_mat_xzr.m` 生成的基带I/Q数据（.mat），通过滑动窗口进行分段，并对每一段数据执行MTD（动目标检测）处理，最后保存MTD结果。

**数据依赖**:

-   **输入**: 依赖 `BasebandRawData_mat` 文件夹中由前一阶段生成的 `frame_*.mat` 文件。
-   **输出**: 生成并保存 `MTD_data_win*` 文件夹中的 `frame_*.mat` 文件。

**函数依赖关系链**:

该脚本的函数调用关系可以概括为一条主链： `main_produce_dataset_win_xzr.m` → `fun_MTD_produce.m` → `fun_lss_pulse_compression.m` → `fun_pulse_compression.m`

以下是详细的层级分解：
#### 各脚本功能详解

##### 2 **`main_produce_dataset_win_xzr.m`** (主流程脚本)
    
-   直接调用 `fun_MTD_produce.m` 来对分割好的数据窗口 (`echo_0`, `echo_1`) 进行完整的MTD处理。
   
###### 2.1 **`fun_MTD_produce.m`** (MTD处理协调函数)
    
-   此函数是MTD处理的核心协调者。
-   直接调用以下三个函数来完成处理：
    -   `fun_lss_pulse_compression.m`: 对包含多个脉冲段的回波数据进行脉冲压缩。
    -   `fun_Process_MTD.m`: 对脉冲压缩后的数据进行加窗和FFT，以转换到距离-多普勒域。
    -   `fun_0v_pressing.m`: 对MTD结果进行零速抑制，以消除静止杂波。
-   _注_: `fun_lss_range_concate.m` 的调用在代码中被注释掉了，因此目前不构成有效依赖。
###### 2.2 **`fun_lss_pulse_compression.m`** (多脉冲-脉冲压缩函数)
    
-   该函数负责处理混合脉冲信号。
-   对短脉冲函数进行简单的FIR滤波器滤波
-   直接调用 `fun_pulse_compression.m` 两次，分别对中脉冲和长脉冲回波进行匹配滤波。

###### 2.3 **`fun_pulse_compression.m`** (基础脉冲压缩函数)
- 对中脉冲和长脉冲信号进行匹配滤波脉冲压缩
- 这个函数是依赖链的末端，它们不依赖于项目中任何其他自定义的 `.m` 文件，仅使用MATLAB的内置函数来完成各自的功能。

###### 2.4 **`fun_Process_MTD.m`**（核心MTD处理部分）
- 具体MTD处理函数，对每个距离单元的数据进行 FFT, abs, max 处理
- 这个函数是依赖链的末端，它们不依赖于项目中任何其他自定义的 `.m` 文件，仅使用MATLAB的内置函数来完成各自的功能。


###### 2.5 **`fun_0v_pressing.m`**（杂波抑制）

-这个函数是依赖链的末端，它们不依赖于项目中任何其他自定义的 `.m` 文件，仅使用MATLAB的内置函数来完成各自的功能。





### `main_cfar.m` 的完整依赖关系

此脚本的功能是加载 `main_produce_dataset_win_xzr.m` 生成的MTD数据，对其执行CFAR（恒虚警率）检测以提取目标，并可以选择性地将结果可视化。

**数据依赖**:

-   **输入**: 依赖 `MTD_data_win*` 文件夹中由前一阶段生成的 `frame_*.mat` 文件。
-   **输出**: 生成并保存 `cfarFlag*` 文件夹中的 `frame_*.mat` 文件，其中包含了CFAR检测结果的标志矩阵。

**函数依赖关系链**:

该脚本的函数调用关系可以概括为： `main_cfar.m` → (本地函数 `fun_CFARflag`) → `executeCFAR.m` → `Function_CFAR1D_sub.m` / `Function_CFAR1D_sub_fixCells.m`

#### 各脚本功能详解

##### 3 **`main_cfar_xzr.m`** (主流程控制脚本)
    
-   直接调用 `fun_0v_pressing.m` 对加载的MTD数据再次进行零速抑制。
-   直接调用其文件中**内部定义**的本地函数 `fun_CFARflag` 来对MTD数据进行CFAR检测。
###### 3.1 **`fun_CFARflag`** (本地函数，定义于 `main_cfar.m` 内部)
    
-   此函数是CFAR处理的直接入口。
-   它将MTD数据按脉冲类型（短、中、长）分割后，多次调用 `executeCFAR.m` 对每一段数据执行核心的CFAR算法。
###### 3.2 **`executeCFAR.m`** (二维CFAR执行函数)
    
-   该函数实现了“先速度维，后距离维”的二维CFAR检测逻辑。
-   直接调用以下两个函数：
    -   `Function_CFAR1D_sub.m`: 对数据的每一列（或转置后的行）执行标准的一维CFAR检测。
    -   `Function_CFAR1D_sub_fixCells.m`: 在速度维检测到目标后，对特定距离单元进行一维CFAR检测。
###### 3.3 **`Function_CFAR1D_sub.m`** 和 **`Function_CFAR1D_sub_fixCells.m`** (底层CFAR工具函数)
    
-   这两个函数是CFAR依赖链的末端，它们实现了具体的一维单元平均CFAR算法，不依赖于项目中任何其他自定义的 `.m` 文件。


## 6/14 日志
### 问题
1. `fun_MTD_produce` 中，参考脉冲信号 手动输入实际情况未知。只能用理想情况仿真模拟。


2. **总采集点数 < 窄中长三个脉冲各自采集点数的和**：`fun_lss_pulse_compression` 中，没法分段做脉冲压缩  
- 采集数据距离做了限制，长脉冲采样点数比实际少，短脉冲和中脉冲采集点数以及总采集点数没问题。

3. `fun_lss_pulse_compression` 中，新的 FIR 滤波器系数未知



## 6/17 日志
### 工作
1. 绘图代码整合为一个主函数（画图分析控制文件）和两个子函数
    - `analyze_and_plot_mtd_results.m`: 主函数
    - `fun_plot_visualizations`: 画图子函数，可以画
    - `fun_plot_mtd_dashboard`: 画图子函数，mtd三维图、mtd二维图、距离维切片以及速度维切片

2. MTD子函数硬编码修改
    - `main_produce_dataset_win_xzr_v2.m` 控制后续MTD所有子函数需要传入的参数，子函数不需要修改参数

## 6/18 日志
### 工作
1. CFAR 部分代码整理调试






