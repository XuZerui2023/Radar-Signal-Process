% main_integrated_processing.m
% 这是一个一体化的雷达信号处理 总控脚本。
% 它将数据读取、MTD处理和CFAR检测三个阶段串联起来，
% 实现了从原始.bin文件到最终CFAR结果的一键式自动化处理。
% 通过配置开关，可以选择性地保存中间阶段的数据。

clc; clear; close all;

%% 1. 全局参数配置区 (所有参数在此统一设置 Config)
fprintf('--- 开始进行全局参数配置 ---\n');

% --- 1.1 流程控制 ---
config.frame_range = 0 : 30;                 % 指定要处理的帧范围
config.save_options.save_iq_mat = true;      % 开关：是否保存第一阶段的.mat格式I/Q数据
config.save_options.save_mtd_mat = true;     % 开关：是否保存第二阶段的MTD结果
config.save_options.save_cfar_mat = true;    % 开关：是否保存第三阶段的CFAR结果

% --- 1.2 路径配置 ---
filepath = uigetdir;                         % 以弹窗的方式进行文件基础路径读取，一般具体到雷达型号和采集日期作为根目录，例如“X8数据采集250522”
if isequal(filepath, 0)
    disp('用户取消了文件选择。');
    return;
else
    fullFile = fullfile(filepath);
    disp(['已选择文件路径: ', fullFile]);
end
config.base_path = filepath;

% --- 1.3 实验数据路径 ---
config.n_exp = 3;  % 具体组数 
config.DBF_coef_path = fullfile(config.base_path, 'DBF_data', 'X8数据采集250522_DBFcoef.csv');          % 用于 DDC 数据波束成形的 DBF 系数，先处理成CSV（逗号分隔值）文件
config.raw_data_path = fullfile(config.base_path, num2str(config.n_exp), '2025年05月22日17时10分05秒'); % 原始二进制 bin  数据文件夹

% --- 1.4 雷达系统基础参数 ---
MHz = 1e6; % 定义MHz单位
config.Sig_Config.c = 2.99792458e8;            % 光速
config.Sig_Config.pi = pi;                     % 圆周率
config.Sig_Config.fs = 25e6;                   % 采样率 (Hz)
config.Sig_Config.fc = 9450e6;                 % 中心频率 (Hz)
config.Sig_Config.timer_freq = 200e6;          % 时标计数频率 
config.Sig_Config.prtNum = 332;                % 定义每帧信号的脉冲数，每帧信号包含 332 个脉冲
config.Sig_Config.point_PRT = 3404;            % 定义每个PRT中的采样点数（时间轴）
config.Sig_Config.channel_num = 16;            % 通道数（阵元数目）
config.Sig_Config.beam_num = 13;               % 波束数
config.Sig_Config.prt = 232.76e-6;             % 脉冲重复时间 (s)
config.Sig_Config.B = 20e6;                    % 带宽 (Hz)
config.Sig_Config.bytesFrameHead = 64;         % 每个PRT帧头字节数
config.Sig_Config.bytesFrameEnd = 64;          % 每个PRT帧尾字节数
config.Sig_Config.bytesFrameRealtime = 128;    % 实时参数的字节数 
config.Sig_Config.tao = [0.16e-6, 8e-6, 28e-6];       % 脉宽 [窄, 中, 长]
config.Sig_Config.point_prt = [3404, 228, 723, 2453]; % 采集点数 [总采集点数，窄脉冲采集点数，中脉冲采集点数，长脉冲采集点数]   
 
% --- 1.5 MTD处理参数 ---
config.mtd.win_size = 4;                          % MTD 窗口切片数  

config.mtd.c = config.Sig_Config.c;               % 光速
config.mtd.pi = config.Sig_Config.pi;             % 圆周率
config.mtd.prtNum = config.Sig_Config.prtNum;     % 每帧信号的脉冲数

config.mtd.fs = config.Sig_Config.fs;             % 采样频率 (Hz)
config.mtd.fc = config.Sig_Config.fc;             % 中心频率 (Hz)
config.mtd.beam_num = config.Sig_Config.beam_num; % 雷达总波束数量
config.mtd.prt = config.Sig_Config.prt;           % 脉冲重复时间 (s)
config.mtd.B = config.Sig_Config.B;               % 带宽 (Hz)
config.mtd.tao = config.Sig_Config.tao;          % 脉宽 [窄, 中, 长]
config.mtd.point_prt = config.Sig_Config.point_prt;    % 采集点数 [总采集点数，窄脉冲采集点数，中脉冲采集点数，长脉冲采集点数]   
config.mtd.prf = 1 / config.mtd.prt;                  
config.mtd.wavelength = config.mtd.c / config.mtd.fc;    % 信号波长
config.mtd.deltaR = config.mtd.c / (2 * config.mtd.fs);  % 距离分辨率由采样率决定

tao1 = config.mtd.tao(1);     % 窄脉宽 
tao2 = config.mtd.tao(2);     % 中脉宽
tao3 = config.mtd.tao(3);     % 长脉宽
K1   = config.mtd.B/tao1;     % 短脉冲调频斜率
K2   = -config.mtd.B/tao2;    % 中脉冲调频斜率（负）
K3   = config.mtd.B/tao3;     % 长脉冲调频斜率


% % --- 1.6 CFAR处理参数 ---
% % --- CFAR核心参数 ---
config.cfar.T_CFAR = 5;   % 门限因子
% config.cfar.MTD_V = 3;    % 杂波区速度范围，速度在 -3 m/s 到 +3 m/s 范围内的区域都当作是地杂波区域，在CFAR检测中忽略掉。
% 
% 
% % --- 速度维参数 ---
% config.cfar.refCells_V = 5;       % 速度维 参考单元数
% config.cfar.saveCells_V = 7;      % 速度维 保护单元数
% config.cfar.T_CFAR_V = config.cfar.T_CFAR; % 速度维恒虚警标称化因子
% config.cfar.CFARmethod_V = 0;     % 0--选大；1--选小
% 
% % --- 距离维参数 ---
% rCFARDetect_Flag = 1; % 距离维CFAR检测操作标志。 0-否； 1-是
% refCells_R = 5;       % 距离维 参考单元数
% saveCells_R = 7;      % 距离维 保护单元数
% T_CFAR_R = config.cfar.T_CFAR;    % 距离维恒虚警标称化因子7,越低，门限越低，虚警率越高
% CFARmethod_R = 0;     % 0--选大；1--选小
% 
% % --- 计算杂波区对应的速度单元数 ---
% config.cfar.deltaDoppler = prf/params.prtNum;     % 计算多普勒频率分辨率
% config.cfar.deltaV = wavelength*deltaDoppler/2;   % 计算速度分辨率：计算出了一个频率单元（deltaDoppler）等效于多少米/秒（m/s）的速度。这个 deltaV 就是雷达能分辨的最小速度差。
% config.cfar.MTD_0v_num = floor(MTD_V/deltaV);     % 计算杂波区的宽度（以单元数计），在进行CFAR检测时，需要以零速为中心，向两侧各跳过 MTD_0v_num 个速度单元，以避开强大的地杂波对噪声估计的干扰。
% 
% % --- 画图参数（绘图坐标轴参数）---
% config.cfar.graph = 0;
% config.cfar.prtNum = config.Sig_Config.prtNum;           % 每帧信号prt数量
% point_prt = params.point_prt(1);  % 3个脉冲的PRT采集点数
% R_point = 6;                      % 每个距离单元长度（两点间距6m）
% r_axis = 0:R_point:point_prt*R_point-R_point; % 距离轴
% fd = linspace(-prf/2,prf/2,prtNum);
% v_axis = fd*wavelength/2;                     % 速度轴
% % v_axis = v_axis(691:845);



% (其他如refCells, saveCells等参数也应在此定义)


% --- 1.7 创建所有输出目录 ---
config.output_paths.iq = fullfile(config.base_path, num2str(config.n_exp), 'BasebandRawData_mat');
config.output_paths.mtd = fullfile(config.base_path, num2str(config.n_exp), ['MTD_data_win', num2str(config.mtd.win_size)]);
config.output_paths.cfar = fullfile(config.base_path, num2str(config.n_exp), ['cfarFlag4_T', num2str(config.cfar.T_CFAR)]);

if config.save_options.save_iq_mat
    mkdir(config.output_paths.iq); 
end

if config.save_options.save_mtd_mat
    mkdir(config.output_paths.mtd); 
end

if config.save_options.save_cfar_mat
    mkdir(config.output_paths.cfar); 
end

%% 2. 初始化与预加载
% --- 加载DBF系数 ---
try
    DBF_coeffs_data = readmatrix(config.DBF_coef_path);
    DBF_coeffs_data_I = double(DBF_coeffs_data(:, 1:2:end));
    DBF_coeffs_data_Q = double(DBF_coeffs_data(:, 2:2:end));
    DBF_coeffs_data_C = DBF_coeffs_data_I + 1j * DBF_coeffs_data_Q;
catch ME
    error('读入DBF系数文件失败: %s', ME.message);
end

% --- 清除所有函数的持久化状态 ---
clear read_continuous_file_stream;
clear FrameDataRead_xzr; 
clear manage_retry_count;

%% 3. 一体化处理主循环
tic;
fprintf('--- 开始一体化处理流程 ---\n');

% --- 为处理"拼接窗口"，需要预读一帧（MTD中为提高相参时间积累，选择拼接上下帧）---
% fprintf('预加载第 %d 帧的数据...\n', config.frame_range(1));
[iq_data1, angle1, success, is_end] = process_stage1_read_data(config.frame_range(1), config, DBF_coeffs_data_C);  % bin_to_mat逻辑封装

if ~success
    error('无法读取第一帧数据，程序中止。请检查数据文件或路径。')
end
 
% --- 信号处理处理主循环 ---
for frame_idx = 1 : length(config.frame_range) - 1
    
    current_frame_num = config.frame_range(frame_idx);
    next_frame_num = config.frame_range(frame_idx + 1);
    % current_frame_num = frame_idx;
    % next_frame_num = frame_idx + 1;
    fprintf('\n================== 正在处理逻辑帧: %d ==================\n', current_frame_num);
    
    % --- STAGE 1: 读取下一帧数据 ---
    fprintf('STAGE 1: 正在从.bin文件流中读取第 %d 帧...\n', next_frame_num) ;
    %[iq_data1, angle1, success, is_end] = process_stage1_read_data(current_frame_num, config, DBF_coeffs_data_C);
    [iq_data2, angle2, success, is_end] = process_stage1_read_data(next_frame_num, config, DBF_coeffs_data_C);

    if ~ success || is_end
        fprintf('无法读取更多帧，处理结束。\n');
        break;
    end     
    
    % (可选) 保存第一阶段的结果
    if config.save_options.save_iq_mat
        sig_data_DBF_allprts = iq_data1;
        servo_angle = angle1;
        save(fullfile(config.output_paths.iq, ['frame_',num2str(current_frame_num),'.mat']),'sig_data_DBF_allprts','servo_angle');
        fprintf('  > 已保存第 %d 帧的I/Q数据。\n', current_frame_num);
    end


    % --- STAGE 2: MTD处理 ---
    if frame_idx ~= 0 % 读取两帧信号后开始处理
        fprintf('STAGE 2: 正在对帧 %d 和 %d 进行MTD处理...\n', current_frame_num, next_frame_num);
        [mtd_results] = process_stage2_mtd(iq_data1, iq_data2, angle1, angle2, config); % 假设您已将MTD逻辑封装

        % 此处为简化，直接嵌入MTD处理逻辑
        echo_win_beams = cell(config.Sig_Config.beam_num, 1);
        for b = 1:config.Sig_Config.beam_num
            echo_now_beam_data = squeeze(iq_data1(:, :, b));
            echo_next_beam_data = squeeze(iq_data2(:, :, b));
            echo_win_beams{b} = [echo_now_beam_data; echo_next_beam_data];
        end
        % (此处省略了MTD的内层循环，实际应调用一个封装好的函数)
        mtd_results = echo_win_beams; % 这是一个示例，实际应为MTD处理后的结果
        fprintf('  > MTD处理完成。\n');
    end

    % (可选) 保存第二阶段的结果
    if config.save_options.save_mtd_mat
        MTD_win_all_beams = mtd_results;
        save(fullfile(config.output_paths.mtd, ['frame_',num2str(current_frame_num),'.mat']),'MTD_win_all_beams');
        fprintf('  > 已保存第 %d 帧的MTD结果。\n', current_frame_num);
    end
   



    % % --- STAGE 3: CFAR检测 ---
    % fprintf('STAGE 3: 正在对MTD结果进行CFAR检测...\n');
    % % [cfar_results] = process_stage3_cfar(mtd_results, config); % 假设您已将CFAR逻辑封装
    % cfar_results = cell(config.Sig_Config.beam_num, 1); % 这是一个示例，实际应为CFAR处理后的结果
    % fprintf('  > CFAR检测完成。\n');
    % 
    % % (可选) 保存第三阶段的结果
    % if config.save_options.save_cfar_mat
    %     cfarFlag_win_all_beams = cfar_results;
    %     save(fullfile(config.output_paths.cfar, ['frame_',num2str(current_frame_num),'.mat']),'cfarFlag_win_all_beams');
    %     fprintf('  > 已保存第 %d 帧的CFAR结果。\n', current_frame_num);
    % end
    
    % --- 为下一次循环准备数据 ---
    iq_data1 = iq_data2;
    angle1 = angle2;
end

toc;
disp('所有一体化处理流程完成。');
